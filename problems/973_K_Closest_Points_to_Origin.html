<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>973_K_Closest_Points_to_Origin</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p><strong>973.  K Closest Points to Origin</strong></p>
<p>Medium</p>
<p>We have a list of  <code>points</code> on the plane. Find the  <code>K</code>  closest points to the origin  <code>(0, 0)</code>.</p>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
<p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> points = [[1,3],[-2,2]], K = 1<br>
<strong>Output:</strong> [[-2,2]]<br>
<strong>Explanation:</strong><br>
The distance between (1, 3) and the origin is sqrt(10).<br>
The distance between (-2, 2) and the origin is sqrt(8).<br>
Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.<br>
We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> points = [[3,3],[5,-1],[-2,4]], K = 2<br>
<strong>Output:</strong> [[3,3],[-2,4]]<br>
(The answer [[-2,4],[3,3]] would also be accepted.)</p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>
<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>
<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>
</ol>
<p><strong>[Solution]</strong></p>
<pre class=" language-javaclass"><code class="prism  language-javaclass">    public int[][] kClosest(int[][] points, int K) {
        int[][] res = new int[K][2];
        
        kTh(points, 0, points.length - 1, K-1);
        
        for (int i = 0; i &lt; K; i++) res[i] = points[i];
        
        return res;
    }
    
    int[] kTh(int[][] points, int l, int u, int k) {
        if (l &gt;= u) return points[l];
        
        Random r = new Random();
        int idx = r.nextInt(u - l + 1) + l;
        swap(points, idx, u);
        
        int pivot = dist(points[u]);
        
        int j = l;
        for (int i = l ; i &lt; u ; i++) {
            if (dist(points[i]) &lt; pivot) swap(points, i, j++);
        }
        swap(points, j, u);
        if (j == k) return points[j];
        else if (j &lt; k) return kTh(points, j+1, u, k);
        else return kTh(points, l, j - 1, k);
    }
    
    
    void swap(int[][] points, int i, int j) {
        int[] t = new int[]{points[i][0], points[i][1]};
        points[i][0] = points[j][0];
        points[i][1] = points[j][1];
        
        points[j][0] = t[0];
        points[j][1] = t[1];
    }
    
    int dist(int[] p) {
        return p[0] * p[0] + p[1] * p[1]; 
    }
}
</code></pre>
</div>
</body>

</html>
