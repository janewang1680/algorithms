<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>420_Strong_Password_Checker</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p><strong>420.  Strong Password Checker</strong></p>
<p>Hard</p>
<p>A password is considered strong if the below conditions are all met:</p>
<ul>
<li>It has at least  <code>6</code>  characters and at most  <code>20</code>  characters.</li>
<li>It contains at least  <strong>one lowercase</strong>  letter, at least  <strong>one uppercase</strong>  letter, and at least  <strong>one digit</strong>.</li>
<li>It does not contain three repeating characters in a row (i.e., <code>"...aaa..."</code>  is weak, but  <code>"...aa...a..."</code>  is strong, assuming other conditions are met).</li>
</ul>
<p>Given a string  <code>password</code>, return  <em>the minimum number of steps required to make  <code>password</code>  strong. if  <code>password</code>  is already strong, return  <code>0</code>.</em></p>
<p>In one step, you can:</p>
<ul>
<li>Insert one character to  <code>password</code>,</li>
<li>Delete one character from  <code>password</code>, or</li>
<li>Replace one character of  <code>password</code>  with another character.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> password = “a”<br>
<strong>Output:</strong> 5</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> password = “aA1”<br>
<strong>Output:</strong> 3</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> password = “1337C0d3”<br>
<strong>Output:</strong> 0</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= password.length &lt;= 50</code></li>
<li><code>password</code>  consists of letters, digits, dot <code>'.'</code>  or exclamation mark  <code>'!'</code>.</li>
</ul>
<p><strong>[Solution]</strong></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token comment">// The basic principle is straightforward: if we want to make MINIMUM changes to turn s into a strong password, each change made should fix as many problems as possible.</span>

<span class="token comment">// So to start, let's first identify all the problems in the input string s and list what changes are suitable for righting each of them. To clarify, each change should be characterized by at least two parts: the type of operation it takes and the position in the string where the operation is applied (Note: Ideally we should also include the characters involved in the operation and the "power" of each operation for eliminating problems but they turn out to be partially relevant so I will mention them only when appropriate).</span>

<span class="token comment">// Length problem: if the total length is less than 6, the change that should be made is (insert, any position), which reads as "the operation is insertion and it can be applied to anywhere in the string". If the total length is greater than 20, then the change should be (delete, any position).</span>

<span class="token comment">// Missing letter or digit: if any of the lowercase/uppercase letters or digits is missing, we can do either (insert, any position) or (replace, any position) to correct it. (Note here the characters for insertion or replacement can only be those missing.)</span>

<span class="token comment">// Repeating characters: for repeating characters, all three operations are allowed but the positions where they can be applied are limited within the repeating characters. For example, to fix "aaaaa", we can do one replacement (replace the middle 'a') or two insertions (one after the second 'a' and one after the fourth 'a') or three deletions (delete any of the three 'a's). So the possible changes are (replace, repeating characters), (insert, repeating characters), (delete, repeating characters). (Note however the "power" of each operation for fixing the problem are different -- replacement is the strongest while deletion is the weakest.)</span>

<span class="token comment">// All right, what's next? If we want a change to eliminate as many problems as it can, it must be shared among the possible solutions to each problem it can fix. So our task is to find out possible overlapping among the changes for fixing each problem.</span>

<span class="token comment">// Since there are most (three) changes allowed for the third problem, we may start from combinations first problem &amp; third problem and second problem &amp; third problem. It's not too hard to conclude that any change that can fix the first or second problems is also able to fix the third one (since the type of operation here is irrelevant, we are free to choose the position of the operation to match those of the repeating characters). For combination first problem &amp; second problem, depending on the length of the string, there will be overlapping if length is less than 6 or no overlapping if length is greater than 20.</span>

<span class="token comment">// From the analyses above, it seems worthwhile to distinguish between the two cases: when the input string is too short or too long.</span>

<span class="token comment">// For the former case, it can be shown that the total changes needed to fix the first and second problems always outnumber those for the third one. Since whatever change used fixing the first two problems can also correct the third one, we may concern ourselves with only the first two. Also as there is overlapping between the changes for fixing the first two problems, we will prefer those overlapping ones, i.e. (insert, any position). Another point is that the characters involved in the operation matters now. To fix the first problem, only those missing characters can be inserted while for the second condition, it can be any character. Therefore correcting the first problem takes precedence over the second one.</span>

<span class="token comment">// For the latter case, there is overlapping between the first &amp; third and second &amp; third problems, so those overlapping changes will be taken, i.e., first problem =&gt; (delete, any position), second problem =&gt; (replace, any position). The reason not to use (insert, any position) for the second problem is that it contradicts the changes made to the first problem (therefore has the tendency to cancel its effects). After fixing the first two problems, what operation(s) should we choose for the third one?</span>

<span class="token comment">// Now the "power" of each operation for eliminating problems comes into play. For the third problem, the "power" of each operation will be measured by the maximum number of repeating characters it is able to get rid of. For example, one replacement can eliminate at most 5 repeating characters while insertion and deletion can do at most 4 and 3, respectively. In this case, we say replacement has more "power" than insertion or deletion. Intuitively the more "powerful" the operation is, the less number of changes is needed for correcting the problem. Therefore (replace, repeating characters) triumphs in terms of fixing the third problem.</span>

<span class="token comment">// Furthermore, another very interesting point shows up when the "power" of operation is taken into consideration (And thank yicui for pointing it out). As I mentioned that there is overlapping between changes made for fixing the first two problems and for the third one, which means the operations chosen above for the first two problems will also be applied to the third one. For the second problem with change chosen as (replace, any position), we have no problem adapting it so that it coincides with the optimal change (replace, repeating characters) made for the third problem. However, there is no way to do the same for the first problem with change (delete, any position). We have a conflict now!</span>

<span class="token comment">// How do we reconcile it? The trick is that for a sequence of repeating characters of length k (k &gt;= 3), instead of turning it all the way into a sequence of length 2 (so as to fix the repeating character problem) by the change (delete, any position), we will first reduce its length to (3m + 2), where (3m + 2) is the largest integer of the form yet no more than k. That is to say, if k is a multiple of 3, we apply once such change so its length will become (k - 1); else if k is a multiple of 3 plus 1, we apply twice such change to cut its length down to (k - 2), provided we have more such changes to spare (be careful here as we need at least two changes but the remaining available changes may be less than that, so we should stick to the smaller one: 2 or the remaining available changes). The reason is that the optimal change (replace, repeating characters) for the third problem will be most "powerful" when the total length of the repeating characters is of this form. Of course, if we still have more changes (delete, any position) to do after that, then we are free to turn the repeating sequence all the way into a sequence of length 2.</span>

<span class="token comment">// Here is the java program based on the above analyses. Both time and space complexity is O(n). Not sure if we can reduce the space down to O(1) by computing the arr array on the fly. A quick explanation is given at the end.</span>


<span class="token comment">// https://www.cnblogs.com/grandyang/p/5988792.html</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strongPasswordChecker</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> carr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>carr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>Character<span class="token punctuation">.</span><span class="token function">isLowerCase</span><span class="token punctuation">(</span>carr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>Character<span class="token punctuation">.</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span>carr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> A <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>Character<span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>carr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> carr<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> carr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> carr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">int</span> total_missing <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> A <span class="token operator">+</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res <span class="token operator">+=</span> total_missing <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">-</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">+</span> total_missing<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> over_len <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> left_over <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            res <span class="token operator">+=</span> over_len<span class="token punctuation">;</span>

            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> over_len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token operator">||</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>over_len<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    over_len <span class="token operator">-=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>over_len<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> over_len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">int</span> need <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> over_len<span class="token punctuation">;</span>
                    over_len <span class="token operator">-=</span> need<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> left_over <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            res <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>total_missing<span class="token punctuation">,</span> left_over<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div>
</body>

</html>
