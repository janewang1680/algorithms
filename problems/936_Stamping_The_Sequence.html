<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>936_Stamping_The_Sequence</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p><strong>936.  Stamping The Sequence</strong></p>
<p>Hard</p>
<p>You want to form a  <code>target</code> string of  <strong>lowercase letters</strong>.</p>
<p>At the beginning, your sequence is  <code>target.length</code> <code>'?'</code>  marks. You also have a  <code>stamp</code> of lowercase letters.</p>
<p>On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp. You can make up to  <code>10 * target.length</code>  turns.</p>
<p>For example, if the initial sequence is  “???”, and your stamp is  <code>"abc"</code>, then you may make  “abc??”, “?abc?”, “??abc” in the first turn. (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.)</p>
<p>If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn. If the sequence is not possible to stamp, return an empty array.</p>
<p>For example, if the sequence is  “ababc”, and the stamp is  <code>"abc"</code>, then we could return the answer  <code>[0, 2]</code>, corresponding to the moves  “???” -&gt; “abc??” -&gt; “ababc”.</p>
<p>Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within  <code>10 * target.length</code> moves. Any answers specifying more than this number of moves will not be accepted.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> stamp = “abc”, target = “ababc”<br>
<strong>Output:</strong> [0,2]<br>
([1,0,2] would also be accepted as an answer, as well as some other answers.)</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> stamp = “abca”, target = “aabcaca”<br>
<strong>Output:</strong> [3,0,1]</p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= stamp.length &lt;= target.length &lt;= 1000</code></li>
<li><code>stamp</code>  and  <code>target</code>  only contain lowercase letters.</li>
</ol>
<p><strong>[Solution]</strong></p>
<pre class=" language-javaclass"><code class="prism  language-javaclass">    public int[] movesToStamp(String stamp, String target) {
        if (target == null || target.length() == 0) return new int[0];
        if (stamp == null || stamp.length() == 0) return new int[0];  
        if (target.indexOf(stamp) == -1) return new int[0];
        
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        char[] arrS = stamp.toCharArray();
        char[] arrT = target.toCharArray();
        
        boolean[] seen = new boolean[target.length()];
        int total = 0;
        while (total &lt; arrT.length) {
            boolean found = false;
            for (int i = 0; i &lt;= arrT.length - arrS.length; i++) {
                if (seen[i]) continue;
                int l = unmatch(arrT, arrS, i);
                if (l == 0) continue;
                seen[i] = true;
                total += l;
                res.add(0, i);
                found = true;
            }
            if (!found) break;
        }
        
        if (total != arrT.length) return new int[0];
        int[] arr = new int[res.size()];
        for (int i = 0; i &lt; arr.length; i++) arr[i] = res.get(i);
        return arr;
    }
    
    int unmatch(char[] arrT, char[] arrS, int start) {
        int l = arrS.length;
        for (int i = 0; i &lt; arrS.length; i++) {
            if (arrT[start+i] == '*') l--;
            else if (arrT[start+i] != arrS[i]) return 0;
        }
        if (l &gt; 0) {
            for (int j = start; j &lt; start+arrS.length; j++) arrT[j] = '*';
        }
        return l;
    }
    
    void print(char[] arr) {
        for (char c: arr) System.out.print(c);
        System.out.println("");
    }
}
</code></pre>
</div>
</body>

</html>
